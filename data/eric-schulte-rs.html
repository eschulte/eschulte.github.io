<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Research Statement</title>
<!-- 2014-01-10 Fri 16:02 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Eric Schulte" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style>@media(min-width:800px){div#content{max-width:800px; padding:2em; margin:auto;}}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Research Statement</h1>
<p>
The current software development ecosystem arose through fifty years
of developers selecting, re-using and modifying software development
tools and techniques through a process that resembles natural
selection.  Effective tools and methods reproduce and evolve while
less useful artifacts are abandoned.  This history has resulted in
some surprising biological features of software.  My work illuminates
and exploits these features to build novel software engineering (SE)
tools and techniques.  Specifically, I apply genetic programming (GP)
techniques to two important real world problems; automated bug repair
and program optimization.  After two decades confined to simplified
languages and non-standard runtimes, genetic techniques have recently
found increased application addressing difficult and software
engineering long-stranding problems.
</p>

<p>
I hope to continue this work towards the end of realizing the initial
goal of GP&#x2013;the automated construction of wholly new software
artifacts and functionality&#x2013;inside of the existing software
development ecosystem.
</p>

<p>
My approach to research seeks to accompany novel SE techniques with
open-source prototype implementations and accompany empirical results
with the tooling and instructions required for reproduction.  I find
an early focus on software development helps to expose problems in
impractical techniques, and released prototypes increases impact by
allowing both researchers and software developers to reproduce, apply
and extend my work.  To this end I have released tools for the genetic
optimization of extant software<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>, for the repair of closed source
binaries<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>, and both libraries<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> and simple command line
tools<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup> for software mutation.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Previous Contributions</h2>
<div class="outline-text-2" id="text-1">
<p>
My research has focused on the natural aspects of computation with an
emphasis on the production of usable tools.  I have made the following
research contributions in reverse chronological order.
</p>

<p>
<b>Genetic Program Repair</b> As part of the Genprog project I helped to
develop a technique of automatic bug repair applicable to real-world
software.  Given a software project with a regression test suite and
at least one failing test, Genprog applies random &ldquo;mutations&rdquo; to the
source code of the original program yielding alternative program
implementations.  In a process mirroring natural selection, an
evolutionary algorithm searches for alternate program implementations
until a version of the program is found which passes the originally
failing test while still passing the entire regression test suite.  In
a systematic study of bugs culled from 8 popular open-source software
projects Genprog was able to repaired 55 of 105 bugs in under 2 hours
of runtime per repair on average.  This work is largely responsible
for the recent increased interest in automatic program repair in the
SE community.
</p>

<p>
<b>Genetic Program Optimization</b> I developed Genetic Optimization
Algorithm (GOA), a technique of post-compiler software optimization
able to reduce the runtime and energy consumption of popular benchmark
programs by 20% as compared to the best optimizations provided by GCC.
Using generic mutation operations an evolutionary algorithm is used to
evolve x86 assembler compiled from an original program to optimize any
aspect of the program&rsquo;s runtime behavior which may be efficiently
measured or modeled.  Recent advances in profiling techniques and the
prevalence of hardware performance counters allow even sophisticated
runtime properties such as energy consumption to be targets of
optimization.  GOA is able to find optimizations specific to both the
target hardware and the workload used for optimization.
</p>

<p>
<b>Software Representation</b> I&rsquo;ve explored multiple methods of
representing and modifying extant software.  I&rsquo;ve extended Genprog
from the modification of C source code, to the modification of LLVM IR
and multiple assembler languages including x86 and ARM independent of
the source language, and I&rsquo;ve even extended these techniques to
directly modify binary executables on multiple architectures including
x86 and MIPS.  This work allows for wider application of genetic
techniques to multiple programming languages, in resource constrained
devices, and to software for which no source code is available (e.g.,
closed source binary executables).  I&rsquo;ve demonstrated this increased
applicability by repairing exploits in a popular NETGEAR router
firmware before the company itself addressed the exploit.  I hope to
continue this work by investigating the power and efficiency of
genetic techniques across multiple representations of extant software.
</p>

<p>
<b>Software Mutational Robustness</b> I&rsquo;ve demonstrated that extant
software (including both large open source projects and a number of
extremely well-tested benchmark programs taken from the software
testing community) has the &ldquo;mutational robustness&rdquo; (meaning the
software&rsquo;s functionality is robust to random mutations at the level of
source code and compiled assembly code) one would expect from an
evolved system.  Mutational robustness has been studied extensively in
biological systems where it is associated with development through
evolution.  Software mutations often yield algorithmically distinct
implementations of a project&rsquo;s implicit specification (demonstrated by
passing the software&rsquo;s test suite).  This work motivates a new view of
software as fundamentally robust to random modification, helps to
explain the success of previous mutation-based SE techniques, and
opens the door to a variety of new methods of software development.
</p>

<p>
<b>Physical Evolutionary Computation</b> I developed a physical
evolutionary computation (PEC) algorithm, designed to run on a unique
hardware platform composed of homogeneous live-plugable distributed
computational tiles.  By eliminating global state and control points
the PEC algorithm is able to run over an unbounded number of tiles,
make use of new tiles attached mid-computation, gracefully degrade
when tiles are removed mid-computation, and function as tile groups
are split and later reconnected.  The algorithm introduced a number of
unique features including real-time mutation rates, and the ability to
map aspects of the problem to the physical dimensions of the hardware.
Although this work explored novel and naturally robust models of
computation, the impact was limited by it&rsquo;s departure from standard
hardware and tooling.  This work taught me the importance of working
within the existing software development environment.
</p>

<p>
<b>Reproducible Research</b>
</p>
<blockquote>
<p>
An article about computational science in a scientific publication is
<i>not</i> the scholarship itself, it is merely <i>advertising</i> of the
scholarship.  The actual scholarship is the complete software
development environment and complete set of instructions which
generated the figures. [Buckheit and Donoho]
</p>
</blockquote>
<p>
I work to ensure that my published empirical results are reproducible.
To this end, I am the author of a widely used open source reproducible
research tool kit<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup> with support for 52 programming languages and
contributions from 63 software developers.  This project has been used
to in publications in fields as diverse as Anthropology, Genetics and
of course Computer Science.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Next Steps</h2>
<div class="outline-text-2" id="text-2">
<p>
I hope to continue the integration of GP techniques into the daily
work-flow of software developers.  This will require new areas of
focus in GP research and will result in the development of new SE
tools.
</p>

<p>
<b>(GP) Representation</b> Genetic techniques are dependent upon software
representations which integrate into existing software development
toolchains, and are modifiable by <i>both</i> software developers and
genetic mutations.  Currently ASM performs surprisingly well as a
target of genetic modifications.  ASM has many properties in common
with DNA including a linear representation, sequential execution in
contiguous segments, the use of reading frames and local jumps.
Unfortunately ASM modifications are not easily communicated back to
software developers.  More work is required to find new program
representations facilitating communication between software developers
and genetic techniques.
</p>

<p>
<b>(GP) Near Optimal Search</b> Software requirements, like ecosystems,
change gradually.  Thus the evolution of extant software is similar to
the evolution of biological systems in that the starting point of the
search, the original program or the wild type organism respectively,
is near optimal.  This deviates sharply from traditional work in GP,
in which the starting population is often a collection of random
candidates with little or no fitness.  New GP techniques for the
evolution of extant software should be informed by the ways in which
biological adaptation is tailored to this process of repeated gradual
improvement.
</p>

<p>
<b>(SE) Software Husbandry</b> In addition to work on the GP front, I plan
to extend recently developed genetic optimization tools.  This work
will combine the current two phase process of (1) software development
followed by (2) post-compiler genetic optimization into an
collaborative model in which a population of evolving software objects
is maintained and is contributed to in parallel by software developers
and evolutionary operations.  This new practice of <i>software
husbandry</i> should have the twin benefits of allowing GP techniques
increased time to improve software and granting software developers a
chance to influence, understand, and work with the evolutionary
process.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Purpose</h2>
<div class="outline-text-2" id="text-3">
<p>
I hope to help make GP techniques part of the standard software
development toolbox.  I see this as a multi-stage project which is
already underway.  Program repair and optimization currently use GP to
modify real-world programs.  Further work refining software
representations and biologically-inspired mutations can increase the
power of such techniques.  Development of tools for software husbandry
will apply GP techniques to the development of novel software in a
setting where human developers may compensate for GP&rsquo;s shortcomings.
Through gradually reducing the role of software developers I hope this
work will culminate in the full GP of useful real-world software.  I
believe that this goal (the original vision of GP) is now become
practical, and although there are certainly unforeseen hurdles and
unasked research questions along the way this future is starting to
take shape.
</p>

<p>
Although this objective is ambitious and sufficient to fill many years
of active work, it is difficult to plan more than a few years ahead.
In addition to software engineering I hope work to leverage computer
systems to perform experimental work of interest to biologists and
ecologists.  Many empirical investigations of evolved systems which
are impractical in biological settings may now be performed in
computational settings.  I look forward to experimental work in both
biologically and computationally evolved systems, and to new tools for
software development and evolution.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="https://github.com/eschulte/optimization">https://github.com/eschulte/optimization</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://github.com/eschulte/netgear-repair">https://github.com/eschulte/netgear-repair</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="https://github.com/eschulte/software-evolution">https://github.com/eschulte/software-evolution</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<code>https://github.com/eschulte/{cil-mutate,clang-mutate,llvm-mutate}</code>
</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
<a href="http://www.jstatsoft.org/v46/i03/">http://www.jstatsoft.org/v46/i03/</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Eric Schulte</p>
<p class="date">Created: 2014-01-10 Fri 16:02</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.4)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
